;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Microcontroller Design Lab 2016
;;  Test program for HaDes on Basys3
;;
;;  13 different tests can be selected
;;  in the main function of this file
;;  (or select more than one test and
;;  jump to the next with the south button)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; special registers
@DEF RA   "r6"
@DEF SP   "r7"

; lookup tables
@data mbtn2led {
  #0x00,#0xC0,#0x03,#0xC3,
  #0x18,#0xD8,#0x1B,#0xDB
@}
@data nib2hex {
  "0123456789ABCDEF"
@}

; global vars
@data test1_val    {#0 @}
@data test2_bcd    {#0 @}
@data test4_pos    {#0 @}
@data test9_cnt    {#0 @}
@data test9_data   {#0, #0, #0 @}
@data test9_x      {#0 @}
@data test9_y      {#0 @}

@data mask {
  #FF11h; white blue striped mask
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; general helper                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@MAC ctx_save {
  store r1, @sp, #0
  store r2, @sp, #1
  store r3, @sp, #2
  store r4, @sp, #3
  store r5, @sp, #4
  store r6, @sp, #5
  addi  @sp, @sp, #6
@}

@MAC ctx_restore {
  subi  @sp, @sp, #6
  load  r6, @sp, #5
  load  r5, @sp, #4
  load  r4, @sp, #3
  load  r3, @sp, #2
  load  r2, @sp, #1
  load  r1, @sp, #0
@}

; wait until exit-button is pressed
; east button
@code wait_button {
wait:
  in    r1, #66
  andi  r1, #0x02	; east button
  beqz  r1, #wait
  out   r1, #66
done:
  jreg @ra
@}

@code ps2_init {
  ; reset controller
  ldui  r1, #0x20
  out   r1, #129

  ; wait until initialized
wait:
  in    r1, #129
  andi  r1, #0x04
  beqz  r1, #wait

  ; done
  jreg @ra
@}

@code ps2_init_mouse {
  ; write mouse-init-byte
  ldui r1, #0xF4
  out  r1, #128
  
  ; receive ack
wait:
  in    r1, #129
  andi  r1, #0x01
  beqz  r1, #wait
  in    r1, #128

  ; done
  jreg @ra
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; console helper                 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; reset XConsole
; (clobbers r1)
@MAC console_reset {
  xnor r1,r0,r0
  out r0,#64
  out r1,#66
  out r0,#67
  out r1,#68
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 1 - 7 segment                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test1_isr {
  ; save context
  @CALL ctx_save

  ; restart timer
  ldui r2, #7
  out  r2, #17
  
  load r1, r0, *d*test1_val
  addi r1, #1
  store r1, r0, *d*test1_val
  
  jal @ra, *bin2bcd     ; convert value in r1 to bcd 
  load r2, r0, *d*test2_bcd
  
  ; 7segment
  ; MSB is the enabled bit
  ; Last 4 Byte are the 4 digits
  ; Bit 17 - 20 set the points
  
  ldui r3, #0x8000	; enable bit
  shli r3, r3, #16
  or r3, r3, r2
  out r3, #224
  
  ; restore context
  @CALL ctx_restore
  reti
@}

@code test1 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset
  
  ; init global variable
  store r0, r0, *d*test1_val
  
  ; start timer
  ldui r2, #0x12c
  out  r2, #16
  ldui r2, #7
  out  r2, #17
  sisa #1, *test1_isr
  eni
  
  ; wait until button is pressed
  jal @ra, *wait_button

  dei
  out r0, #17
  
  ldui r1, #0x0	; reset 7seg
  out r1, #224
  
  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 2 - 7 segment 2                                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; bin2bcd - result into r2
@code bin2bcd {

  ; save context
  @CALL ctx_save
  
  ; r1 binary value
  ; r2 bcd result
  ; r3 help variable
  ; r4 help variable
  ; r5 counter
  ldui r2, #0
  ldui r5, #16
 
bin2bcd1:
  andi r3, r2, #0x000F    ; check last digit
  sgei r4, r3, #0x5       ; greater 5 --> add 3
  bnez r4, #bin2bcdadd3
  jmp #bin2bcddigit2

bin2bcdadd3:
  andi r2, r2, #0xFFF0
  addi r3, r3, #0x3
  andi r3, r3, #0x000F
  or r2, r2, r3           ; add 3 in last digit 
  
bin2bcddigit2:
  andi r3, r2, #0x00F0    ; check second digit
  sgei r4, r3, #0x50      ; greater 5 --> add 3
  bnez r4, #bin2bcdadd30
  jmp #bin2bcddigit3
  
bin2bcdadd30:
  andi r2, r2, #0xFF0F
  addi r3, r3, #0x30
  andi r3, r3, #0x00F0
  or r2, r2, r3           ; add 3 << 4
  
bin2bcddigit3:
  andi r3, r2, #0x0F00    ; check third digit
  sgei r4, r3, #0x500     ; greater 5 --> add 3
  bnez r4, #bin2bcdadd300
  jmp #bin2bcddigit4
  
bin2bcdadd300:
  andi r2, r2, #0xF0FF
  addi r3, r3, #0x300
  andi r3, r3, #0x0F00
  or r2, r2, r3           ; add 3 << 8  
  
bin2bcddigit4:
  andi r3, r2, #0xF000    ; check third digit
  sgei r4, r3, #0x5000    ; greater 5 --> add 3
  bnez r4, #bin2bcdadd3000
  jmp #bin2bcd2
  
bin2bcdadd3000:
  andi r2, r2, #0x0FFF
  addi r3, r3, #0x3000
  andi r3, r3, #0xF000
  or r2, r2, r3           ; add 3 << 12
 
bin2bcd2:
  shli r2, r2, #1     ; shift everything one time to the left
  dec r5              ; decrement counter down to zero
  shr r4, r1, r5      ; shift 15 then 14 then 13 ...
  andi r4, r4, #0x0001; only last bit
  or r2, r2, r4       ; shift r1 into r2
  
bin2bcd3:
  beqz r5, #bin2bcdexit ; exit if shifted 16 times
  
bin2bcd4:
  jmp #bin2bcd1
  
bin2bcdexit:
  ; restore context & return
  store r2, r0, *d*test2_bcd
  
  @CALL ctx_restore
  jreg @ra
@}

@code test2 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset
  
  ldui r1, #12 ; current value
  
  store r0, r0, *d*test2_bcd ; init global variable
  
waitT1:
  jal @ra, *bin2bcd     ; convert value in r1 to bcd 
  load r2, r0, *d*test2_bcd
  
  ; write 7-segment reg
  ldui r3, #0x8000
  shli r3, r3, #16
  or r3, r3, r2
  out r3, #224

waitT2:
  ; read switch status
  in    r2, #65
  
  ; update LEDs
  andi  r2, r2, #0xFFFF
  out   r2, #64
  
  ; read buttons
  in    r3, #66
  andi  r4, r3, #0b0100 ; south
  bnez  r4, #waitT3   	; substract button (south button)
  
  andi  r4, r3, #0b0001 ; north
  bnez  r4, #waitT4   	; add button (north button)
  
  andi  r4, r3, #0b1000 ; west
  bnez  r4, #waitT5		; set number to zero
  
  andi  r4, r3, #0b0010 ; east
  bnez  r4, #test2exit  ; exit button east
  
  jmp #waitT2

waitT3:
  sub r1, r1, r2  ; add value
  out r3, #66     ; reset buttons
  jmp #waitT1

waitT4:
  add r1, r1, r2  ; substract value
  out r3, #66     ; reset buttons
  jmp #waitT1

waitT5:
  ldui r1, #0	  ; set value to zero
  out r3, #66	  ; reset buttons
  jmp #waitT1

test2exit: 
  ; restore context & return
  
  ldui r1, #0x0	; reset 7seg
  out r1, #224
  
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 3 - LED blink                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test3 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset
  
  ; make all LEDs blink
  ldui r1, #0x5555
  shli r1, r1, #16
  ori r1, #0x5555
  
  out  r1, #64

  ; wait until button is pressed
  jal @ra, *wait_button
  
  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 4 - LED walk                                                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test4_upd {
  load  r1, r0, *d*test4_pos
  inc   r1
  andi  r1, #0xf
  store r1, r0, *d*test4_pos
  ldui r2, #1
  shl  r2, r2, r1
  out  r2, #64
  jreg @ra
@}

@code test4_isr {
  ; save context
  @CALL ctx_save

  ; restart timer
  ldui r1, #7
  out  r1, #17

  ; update LEDs
  jal @ra, *test4_upd
  
  ; restore context
  @CALL ctx_restore
  reti
@}

@code test4 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset

  ; init LEDs
  store r0, r0, *d*test4_pos
  jal @ra, *test4_upd

  ; start timer
  ldui r1, #0x3e8
  out  r1, #16
  ldui r1, #7
  out  r1, #17
  sisa #1, *test4_isr
  eni

  ; wait until button is pressed
  jal @ra, *wait_button

  ; stop timer
  dei
  out r0, #17

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 5 - Switch Test                                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test5 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset

loop:
  ; get switches
  in    r5, #65

  ; update LEDs
  andi  r1, r5, #0xFFFF
  out   r1, #64
  
  ldui r3, #0x8000
  shli r3, r3, #16
  or r3, r3, r5
  out r3, #224

  ; check if exit button pressed
  in    r1, #66
  andi  r1, #0x02   ; east button
  beqz  r1, #loop
  out   r1, #66

  ldui r3, #0x0000	; reset 7seg
  out r3, #224
  out r3, #64
  
  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 6 - Button Test                                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test6 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset
  
  ; init status
  ldui  r4, #0

loop:
  ; get & ack switches
  in    r5, #66
  out   r5, #66

  ; update status
  andi  r1, r5, #0xF
  xor   r4, r4, r1

  ; update LEDs
  andi  r1, r4, #0xFFFF
  out   r1, #64

  ; check for exit-button
  andi  r5, #0x02			; east button
  beqz  r5, #loop

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 8 - UART                                                             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test8_isr {
  ; save context
  @CALL ctx_save

next:
  ; check if data was received
  in   r1, #97
  andi r1, r1, #1
  beqz r1, #done

  ; receive & echo byte
  in   r5, #96
  out  r5, #96

  ; check for more data
  jmp #next

done:
  ; restore context
  @CALL ctx_restore
  reti
@}

@code test8 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset

  ; configure UART
  ldui r1, #1
  out  r1, #98
  sisa #1, *test8_isr
  eni

  ; wait until button is pressed
  jal @ra, *wait_button

  ; disable IRQs
  dei

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 9 - Mouse                                                            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test9_parse {
  ; save context
  @CALL ctx_save

  ; read frame from buffer
  ldui r5, *d*test9_data
  load r3, r5, #0
  load r4, r5, #1
  load r5, r5, #2

  ; sign-expand x-offset if required
  andi  r1, r3, #0x10
  beqz  r1, #x_positive
  ldi   r1, #0xFF00
  or    r4, r4, r1
x_positive:

  ; sign-expand y-offset if required
  andi  r1, r3, #0x20
  beqz  r1, #y_positive
  ldi   r1, #0xFF00
  or    r5, r5, r1
y_positive:

  ; update x-pos
  load  r1, r0, *d*test9_x
  add   r4, r4, r1
  store r4, r0, *d*test9_x

  ; update y-pos
  load  r1, r0, *d*test9_y
  add   r5, r5, r1
  store r5, r0, *d*test9_y

  
  addi r1, r4, #0 ; x-coord
  shri r1, r1, #2 ; scale down
  jal @ra, *bin2bcd     ; convert value in r1 to bcd  
  load r4, r0, *d*test2_bcd
  
  addi r1, r5, #0 ; y-coord
  shri r1, r1, #2 ; scale down
  jal @ra, *bin2bcd     ; convert value in r1 to bcd  
  load r5, r0, *d*test2_bcd
  
  andi r4, r4, #0x00FF
  shli r4, r4, #8
  andi r5, r5, #0x00ff
  or r5, r5, r4  
  
  ldui r4, #0x8000
  shli r4, r4, #16
  or r4, r4, r5
  out r4, #224

  ; update LEDs
  andi  r1, r3, #0x7
  out   r1, #64 
  
  ; restore context
  @CALL ctx_restore
  jreg @ra
@}

@code test9_rxbyte {
  ; save context
  @CALL ctx_save

  ; load byte-counter
  load  r4, r0, *d*test9_cnt

  ; receive byte
  in    r5, #128
  
  ; store byte into buffer
  store r5, r4, *d*test9_data

  ; update byte-counter
  inc   r4
  sgei  r3,r4,#3
  beqz  r3, #done

  ; parse frame
  jal   @ra, *test9_parse

  ; reset byte-counter
  ldui  r4, #0

done:
  ; save byte-counter
  store r4, r0, *d*test9_cnt

  ; restore context
  @CALL ctx_restore
  jreg @ra
@}

@code test9_isr {
  ; save context
  @CALL ctx_save

next:
  ; check if data was received
  in   r1, #129
  andi r1, r1, #1
  beqz r1, #done

  ; handle byte
  jal @ra, *test9_rxbyte

  ; check for more data
  jmp #next

done:
  ; restore context
  @CALL ctx_restore
  reti
@}

@code test9 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset

  ; init global vars
  store r0, r0, *d*test9_cnt
  store r0, r0, *d*test9_x
  store r0, r0, *d*test9_y

  ; init PS/2
  jal @ra, *ps2_init
  in   r1, #129
  andi r1, r1, #0x18
  seqi r1, r1, #0x08
  beqz r1, #nodev

  ; init mouse
  jal @ra, *ps2_init_mouse


  ; mouse found => enable IRQ
  ldui r1, #1
  out  r1, #130
  sisa #1, *test9_isr
  eni
  jmp #run

nodev:
  ldui r5, #0x8000
  shli r5, r5, #16
  ori r5, #0x8888
  out r5, #224
  
  jmp #run

run:
  ; wait until button is pressed
  jal @ra, *wait_button

  ; disable IRQs
  dei
  
  ldui r1, #0x0	; reset 7seg
  out r1, #224

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 10 - Keyboard                                                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test10_isr {
  ; save context
  @CALL ctx_save

  ; check if data was received
  in   r1, #129
  andi r1, r1, #1
  beqz r1, #done

  ; receive byte and set the ASCII to the leds
  in   r5, #128
  out  r5, #64

done:
  ; restore context
  @CALL ctx_restore
  reti
@}

@code test10 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset
  
  ; init PS/2
  jal @ra, *ps2_init
    
  in   r1, #129
  andi r1, r1, #0x18
  seqi r1, r1, #0x18
  beqz r1, #nodev

  ; kayboard found => enable IRQ
  ldui r1, #1
  out  r1, #130
    
  ldui r5, #0x8000
  shli r5, r5, #16
  ori r5, #0x1
  out r5, #224
  
  sisa #1, *test10_isr
  eni
  jmp #run

nodev:
  ldui r5, #0x8000
  shli r5, r5, #16
  ori r5, #0x8888
  out r5, #224
  
  jmp #run

run:
  ; wait until button is pressed
  jal @ra, *wait_button

  ; disable IRQs
  dei

  ldui r1, #0x0	; reset 7seg
  out r1, #224
  
  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 11 - VGA 1                                                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@data vga_pattern1 {
  #0x0000,#0x0000,  ; black
  #0xFFFF,#0xFFFF,  ; white
  #0x4444,#0x4444,  ; red
  #0x2222,#0x2222,  ; green
  #0x1111,#0x1111,  ; blue
  #0xFFFF,#0x0000,  ; horizontal stripes
  #0xFF00,#0xFF00,  ; vertical stripes
  #0x00FF,#0xFF00	; check pattern
@}

@code test11_fill {
  ; save context
  @CALL ctx_save

  ; reset address
  out  r0, #160

  ; get pattern
  ldui r3, *d*vga_pattern1
  shli r1, r1, #1
  add  r3, r3, r1
  load r2, r3, #1
  load r1, r3, #0

  ; init counter
  ldui r3, #0x2580  ; r2 = 0x2580 = (640*480/32)
  ldui r4, #20

  ; fill screen
fill:
  out  r1, #162
  out  r1, #162
  out  r1, #162
  out  r1, #162
  out  r1, #162
  out  r1, #162
  out  r1, #162
  out  r1, #162
  dec  r4
  beqz r4, #nline
  jmp  #l2
nline:
  ; swap patterns & reload counter
  ld   r4, r1
  ld   r1, r2
  ld   r2, r4
  ldui r4, #20
l2:
  dec  r3
  bnez r3, #fill

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}

@code test11 {
  ; save context
  @CALL ctx_save

  ; bring periphery to known state
  @CALL console_reset

  ldui	r5, #0x07

loop:
  ; change pattern
  in    r2, #66
  andi  r3, r2, #0x01
  beqz	r3, #check_sub
  out   r2, #66
  addi	r5, r5, #0x01
check_sub:
  andi  r3, r2, #0x04
  beqz  r3, #check_invalid_selection
  out   r2, #66
  subi	r5, r5, #0x01
check_invalid_selection:
  andi  r5 , r5, #0x07
fill_screen:
  ; fill screen
  ld    r1, r5
  jal   @ra, *test11_fill

  ; check for exit-button
  in    r1, #66
  andi  r1, #0x02
  beqz  r1, #loop
  out   r1, #66

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 12 - VGA 2 pattern                                                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test12 {
  ; save context
  @CALL ctx_save


  ; reset address
  out  r0, #160

  ; clear y
  ldui r3, #0
yloop:
  ; clear x
  ldui r2, #0
  xloop:
    ; handle pixel

    ; R
    muli r4,r2,#0x666
    shri r4,r4,#16
    shli r1,r4,#8

    ; G
    muli r4,r3,#0x888
    shri r4,r4,#16
    shli r4,r4,#4
    or   r1,r1,r4

    ; B
    subi r4,r2,#320
    subi r5,r3,#240
    mul  r4,r4,r5
    slt  r5,r4,r0
    beqz r5, #l1
    muli r4,r4,#-1
l1:
    muli r4,r4,#0xD
    shri r4,r4,#16
    or   r1,r1,r4

    ; output pixel
    out  r1,#161

    ; increment x
    inc  r2
    sgei r1,r2,#640
    beqz r1,#xloop

  ; increment y
  inc  r3
  sgei r1,r3,#480
  beqz r1,#yloop

  ; wait until button is pressed
  jal @ra, *wait_button

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test 13 - VGA 3 white and blue stripes                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code test13 {
  ; save context
  @CALL ctx_save

  @ldef counter "r3" 
  @ldef mask "r4"
  
; reset address
  out  r0, #160

  ldui @counter, #0b1001011
  shli @counter, @counter, #10 ; init counter 307200/4
  load @mask, r0, *d*mask ; load mask
  
loop:
  out @mask, #162 ; save mask, FASTBUFFER
  dec @counter ; decrement counter
  bnez @counter, #loop	; check if finish
 
  ; wait until button is pressed
  jal @ra, *wait_button

  ; restore context & return
  @CALL ctx_restore
  jreg @ra
@}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; main function                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code main {
  ; save context
  @CALL ctx_save

  ; run tests
loop:
  jal   @ra, *test1   ; 7 segment
  jal   @ra, *test2   ; 7 segment calculator
  jal   @ra, *test3   ; led_blink
  jal   @ra, *test4   ; led_walk
  jal   @ra, *test5   ; switches
  jal   @ra, *test6   ; buttons
  jal   @ra, *test8   ; UART
  jal   @ra, *test9   ; mouse
  jal   @ra, *test10  ; keyboard
  jal   @ra, *test11  ; vga1
  jal   @ra, *test12  ; vga2
  jal   @ra, *test13  ; vga3
  jmp   #loop

  ; restore context & return
  @CALL ctx_restore
  jreg  @ra
@}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;program entry                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@code __init {
  ; disable program-memory access
  dpma

  ; disable interrupts
  dei

  ; init stack-pointer
  ldui @sp, #2048
  ;shli @sp, @sp, #16

  ; call main
  jal @ra, *main

  ; done, just wait forever
done:
  jmp #done
@}
